摘要：泛型出现虽然保证了代码的正确性，但是对于引用传递会带来参数统一问题，
本节主要在泛型基础上讲解引用传递所带来的新问题，并讲解了泛型上限与泛型下限概念与应用。

虽然泛型帮助开发者解决了对象的强制转换所带来的安全隐患，但是泛型也带来了一些新的问题：引用传递处理。

范例：观察问题的产生
这个时候问题就也就出现了，而问题的关键在于fun()方法上，如果真的去使用泛型，不可能只是一种类型，
也就是fun()这个方法应该接受任意种泛型的Message对象。但是这个时候它只能接受“Message<String>”类型，
这种情况下就有同学提出：老师，不设置泛型了

泛型的确解决了安全隐患的问题，但是增加了一个新的问题：怎么进行引用传递呢？
如果不能进行引用传递，那么加泛型的意义就不大了。

范例：使用通配符
此时在fun()方法中由于采用了Message类结合通配符的处理所以可以接受所有的类型，并且不允许修改只允许获取数据。
在”T“通配符的基础之上实际还提供有两类小的通配符：
- T extends 类：设置泛型的上限；
    |- 例如 “<T extends Number>” :表示该泛型类型只允许设置Number或Number的子类；
- T Super 类：设置泛型的下限；
    |-例如 “<T super String>” :表示只能够使用String或其父类

范例：观察泛型的上限配置
泛型的上下限这些代码有可能不经常出现，但是必须得看明白怎么么回事，因为系统类库中充斥着大量的这种操作结构，
而且他们还可能会加嵌套，泛型套其他类型，其他类型再套泛型，再套其他类型，再套泛型。

范例：设置泛型下限
//这里super String类之后上面实例化对象给泛型的时候只能写String类和String类的父类Object类

对于通配符而言是一个重要的概念，并且要求一定能理解此概念的定义，在日后学习Java一些系统类库的时候会见到大量的通配符使用。
