摘要：泛型可以在编译时检测出程序的安全隐患，使用泛型技术可以使程序更加健壮，本课程讲解了如何利用泛型来解决ClassCastException问题。
泛型定义：

如果想要项目之中避免出现”ClassCastException”，最好的做法是直接回避掉对象的强制转换，所以在JDK1.5之后提供了泛型的技术，
而泛型的本质在于：类中的属性或方法的参数与返回值类型可以由对象实例化的时候动态决定，那么就需要在类定义的时候明确定义占位符（泛型标记）

提示：关于默认的泛型类型
    由于泛型是属于JDK1.5之后的产物，但是在这之前已经有不少内置的程序类或者是接口广泛地应用在了项目开发之中，于是为了保证这些类或接口
    追加了泛型之后，原始的程序类依然可以使用，所以如果不设置泛型类型时，自动使用Object作为类型以保证程序的正常执行，但在编译的时候会出现警告信息。

泛型定义完成后可以在实例化对象的时候进行泛型类型的设置，一旦设置之后，里面的x与y的属性的类型就与当前对象直接绑定了。

现在的程序代码之中，由于给point类对象设置的泛型类型为Integer，这样这个对象所有对应子泛型的属性、变量、方法返回值就将全部替换为Integer(只局限于此对象之中),
这样在进行处理的时候如果发现设置的内容有错误，则会在程序编译的时候自动进行错误提示，同时也避免了对象的向下转型处理(避免安全隐患).

泛型的使用注意点：
- 泛型之中只允许设置引用类型，如果要操作基本类型必须使用包装类；
- 从JDK1.7开始，泛型对象实例化可以简化为“Point<Integer> point = new Point<>();”(后面的泛型类型可以省略)

除了 int 和 char 两者的包装类名变化了，其余六种基本类型对应的包装类名，都只是大写了首字母而已。

使用泛型可以解决大部分的类对象的强制转换处理，这样的程序才是一个合理的设计。
用Object接受全部数据的时代已经是过去式了，是以前的代码，现在我们所有的设计应该更加严格，对象操作的时候应该指明类型，这就是泛型的主要特点！